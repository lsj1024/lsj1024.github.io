<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		事务 | 
	 
	lsj的笔记
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "lsj1024.github.io";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">lsj的笔记</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	

	

		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/wujun234" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="file">
									<a href="/2022/04/18/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/">
										B树和B+树的区别
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/04/18/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">
										Redis分布式锁的实现原理
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/09/09/hello-world/">
										hello-world
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2021/11/04/%E4%BA%8B%E5%8A%A1/">
										事务
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/04/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
										并发编程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
										计算机网络
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	事务
</h1>
<div class="article-meta">
	
	<span>lsj</span>
	<span>2021-11-04 10:02:19</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
    

    
		<span>Tags：</span>
            
    
		</div>

</div>

<div id="article-content">
	<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>使用方式：@Transactional(rollbackFor = Exception.class)</p>
<p>原理： 基于spring-AOP，基于动态代理，在方法上加入该注解后，在创建bean时会</p>
<h1 id="一-spring事务"><a href="#一-spring事务" class="headerlink" title="一.spring事务"></a>一.spring事务</h1><h2 id="1-事务的特性"><a href="#1-事务的特性" class="headerlink" title="1.事务的特性"></a>1.事务的特性</h2><ul>
<li>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li>
<li>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</li>
<li>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</li>
<li>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。</li>
</ul>
<h2 id="2-Spring事务的配置方式"><a href="#2-Spring事务的配置方式" class="headerlink" title="2.Spring事务的配置方式"></a>2.Spring事务的配置方式</h2><p>Spring支持编程式事务管理以及声明式事务管理两种方式。</p>
<ul>
<li><strong>编程式事务管理</strong></li>
</ul>
<p>​      编程式事务管理是侵入性事务管理，使用TransactionTemplate或者直接使用PlatformTransactionManager，对于编程式事务管理，Spring推荐使用TransactionTemplate。</p>
<ul>
<li><strong>声明式事务管理</strong></li>
</ul>
<p>​    声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。</p>
<p>​    注解源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line">    <span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>​    编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。<br>​    显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的编程方式。唯一不足的地方就是声明式事务管理的粒度是方法级别，而编程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式事务管理的配置。</p>
<h2 id="3-事务的传播行为（Propagation）"><a href="#3-事务的传播行为（Propagation）" class="headerlink" title="3. 事务的传播行为（Propagation）"></a>3. 事务的传播行为（Propagation）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line">    REQUIRED(<span class="number">0</span>),</span><br><span class="line">    SUPPORTS(<span class="number">1</span>),</span><br><span class="line">    MANDATORY(<span class="number">2</span>),</span><br><span class="line">    REQUIRES_NEW(<span class="number">3</span>),</span><br><span class="line">    NOT_SUPPORTED(<span class="number">4</span>),</span><br><span class="line">    NEVER(<span class="number">5</span>),</span><br><span class="line">    NESTED(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Propagation</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（1）<strong>REQUIRED</strong></p>
<p>这个是默认的属性<br>Support a current transaction, create a new one if none exists.<br>如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。<br>被设置成这个级别时，会为每一个被调用的方法创建一个逻辑事务域。如果前面的方法已经创建了事务，那么后面的方法支持当前的事务，如果当前没有事务会重新建立事务。 </p>
<p>（2）<strong>MANDATORY</strong><br>Support a current transaction, throw an exception if none exists.</p>
<p>支持当前事务，如果当前没有事务，就抛出异常。 </p>
<p>（3）<strong>NEVER</strong><br>Execute non-transactionally, throw an exception if a transaction exists.<br>以非事务方式执行，如果当前存在事务，则抛出异常。 </p>
<p>（4）<strong>NOT_SUPPORTED</strong><br>Execute non-transactionally, suspend the current transaction if one exists.<br>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </p>
<p>（5）<strong>REQUIRES_NEW</strong><br>Create a new transaction, suspend the current transaction if one exists.<br>新建事务，如果当前存在事务，把当前事务挂起。 </p>
<p>（6）**SUPPORTS **<br>Support a current transaction, execute non-transactionally if none exists.<br>支持当前事务，如果当前没有事务，就以非事务方式执行。 </p>
<p>（7）<strong>NESTED</strong><br>Execute within a nested transaction if a current transaction exists, behave like PROPAGATION_REQUIRED else.<br>支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。<br>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。 </p>
<p><strong>使用介绍:</strong><br>@Transactional(propagation=Propagation.REQUIRED)<br>如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)<br>@Transactional(propagation=Propagation.NOT_SUPPORTED)<br>容器不为这个方法开启事务<br>@Transactional(propagation=Propagation.REQUIRES_NEW)<br>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务<br>@Transactional(propagation=Propagation.MANDATORY)<br>必须在一个已有的事务中执行,否则抛出异常<br>@Transactional(propagation=Propagation.NEVER)<br>必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)<br>@Transactional(propagation=Propagation.SUPPORTS)<br>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务.</p>
<p> PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别<br>它们非常 类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA 事务管理器的支持。<br>使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。 </p>
<h2 id="4-事务的隔离级别（Isolation-Level"><a href="#4-事务的隔离级别（Isolation-Level" class="headerlink" title="4. 事务的隔离级别（Isolation Level)"></a>4. 事务的隔离级别（Isolation Level)</h2><p>事务并发引起的三种情况 ：</p>
<ul>
<li><p>Dirty Reads 脏读 </p>
<p>一个事务正在对数据进行更新操作，但是更新还未提交，另一个事务这时也来操作这组数据，并且读取了前一个事务还未提交的数据，而前一个事务如果操作失败进行了回滚，后一个事务读取的就是错误数据，这样就造成了脏读。</p>
</li>
<li><p>Non-Repeatable Reads 不可重复读<br>一个事务多次读取同一数据，在该事务还未结束时，另一个事务也对该数据进行了操作，而且在第一个事务两次次读取之间，第二个事务对数据进行了更新，那么第一个事务前后两次读取到的数据是不同的，这样就造成了不可重复读。</p>
</li>
<li><p>Phantom Reads 幻像读<br>第一个数据正在查询符合某一条件的数据，这时，另一个事务又插入了一条符合条件的数据，第一个事务在第二次查询符合同一条件的数据时，发现多了一条前一次查询时没有的数据，仿佛幻觉一样，这就是幻像读。</p>
</li>
</ul>
<p> 也就是：</p>
<p><strong>脏读</strong> : 一个事务读取到另一事务未提交的更新数据<br><strong>不可重复读</strong> : 在同一事务中, 多次读取同一数据返回的结果有所不同, 换句话说,<br>后续读取可以读到另一事务已提交的更新数据. 相反, “可重复读”在同一事务中多次<br>读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事务已提交的更新数据<br><strong>幻读</strong> : 一个事务读到另一个事务已提交的insert数据</p>
<p><strong>不可重复读重点在于update和delete，而幻读的重点在于insert。</strong></p>
<p><strong>非重复度和幻像读的区别</strong><br>     非重复读是指同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。(A transaction rereads data it has previously read and finds that another committed transaction has modified or deleted the data. )</p>
<p>​    幻像读是指同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻像读。(A transaction reexecutes a query returning a set of rows that satisfies a search condition and finds that another committed transaction has inserted additional rows that satisfy the condition. )</p>
<p>​    表面上看，区别就在于非重复读能看见其他事务提交的修改和删除，而幻像能看见其他事务提交的插入。 </p>
<p><strong>spring事务隔离级别</strong></p>
<p>注解源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line">    DEFAULT(-<span class="number">1</span>),</span><br><span class="line">    READ_UNCOMMITTED(<span class="number">1</span>),</span><br><span class="line">    READ_COMMITTED(<span class="number">2</span>),</span><br><span class="line">    REPEATABLE_READ(<span class="number">4</span>),</span><br><span class="line">    SERIALIZABLE(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Isolation</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（1） <strong>DEFAULT</strong> （默认）<br>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.另外四个与JDBC的隔离级别相对应 。</p>
<p>（2）<strong>READ_UNCOMMITTED</strong> （读未提交）<br>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。 </p>
<p>（3）<strong>READ_COMMITTED</strong> （读已提交）<br>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。 </p>
<p>（4）<strong>REPEATABLE_READ</strong> （可重复读）<br>这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读 </p>
<p>（5）<strong>SERIALIZABLE</strong>（串行化）<br>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。 </p>
<p>隔离级别解决事务并行引起的问题 </p>
<table>
<thead>
<tr>
<th></th>
<th align="center">Dirty reads(脏读)</th>
<th align="center">non-repeatable reads（不可重复读）</th>
<th align="center">phantom reads （幻读）</th>
</tr>
</thead>
<tbody><tr>
<td>Serializable（串行化）</td>
<td align="center">不会</td>
<td align="center">不会</td>
<td align="center">不会</td>
</tr>
<tr>
<td>REPEATABLE READ（可重复读）</td>
<td align="center">不会</td>
<td align="center">不会</td>
<td align="center">会</td>
</tr>
<tr>
<td>READ COMMITTED（读已提交）</td>
<td align="center">不会</td>
<td align="center">会</td>
<td align="center">会</td>
</tr>
<tr>
<td>Read Uncommitted（读未提交）</td>
<td align="center">会</td>
<td align="center">会</td>
<td align="center">会</td>
</tr>
</tbody></table>
<p>MYSQL: 默认为REPEATABLE_READ（可重复读）级别<br>SQLSERVER: 默认为READ_COMMITTED（读已提交）</p>
<h2 id="5-事务超时设置"><a href="#5-事务超时设置" class="headerlink" title="5.事务超时设置"></a>5.事务超时设置</h2><p>@Transactional(timeout=30) //默认-1， 永不超时</p>
<h1 id="二-Transactional-原理"><a href="#二-Transactional-原理" class="headerlink" title="二. Transactional 原理"></a>二. Transactional 原理</h1><p>Transactional注解</p>
<h1 id="三-Mysql事务"><a href="#三-Mysql事务" class="headerlink" title="三. Mysql事务"></a>三. Mysql事务</h1><h2 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1.死锁"></a>1.死锁</h2><p>​    死锁是指两个或多个事务咋说同一资源上相互占用，并请求对方占用的资源，从而导致恶性循坏的现象。</p>
<p>MySQL中 InnnoDB针对死锁的处理方案是: 检测到死锁后（银行家算法？），将持有最少行级排他锁的事务回滚。</p>
<h2 id="2-自动提交"><a href="#2-自动提交" class="headerlink" title="2.自动提交"></a>2.自动提交</h2><p>MySQL默认采用自动提交模式。也就是说，如果不是显式的开启一个事务，每次查询都会被当成一个事务提交操作。（select也是开启事务的）。</p>
<p>在当前连接中，可以通过设置AUTOCOMMIT变量来启用或关闭自动提交。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 是否开启自动提交</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;AUTOCOMMIT&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>设置自动提交：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启自动提交  1（on）：开启；0(off)：关闭</span></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></table></figure>

<p>改变隔离级别：</p>
<p>若更改全局的隔离级别，需要在配置文件中设置；若改变当前会话的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure>

<h2 id="3-MVCC"><a href="#3-MVCC" class="headerlink" title="3.MVCC"></a>3.MVCC</h2><p>MVCC 既多版本并发控制协议。</p>
<p>MVCC的实现原理：</p>
<p>​    相当于在启用每次事务前，都对修改前的数据做了一次”快照“，当然这个快照不是传统意义上的快照，而是使用逻辑协议来实现的-为每个记录增加一个版本号，规定：</p>
<p>​    select：</p>
<p>​        a：每次查询，只查早于当前版本号的数据。也就是说，行的版本号小于或等于当前事务的版本号（版本号是递增的）。这样就可以保证，查到的数据要么是在事务开始之前就已经存在，要么是该事务自身操作过的数据。</p>
<p>​        b：行的删除版本号要么未被定于，要么大于当前事务的版本号。这样可以保证删除的数据在事务开始之前就已经被删除。</p>
<p>​    MySQL在表的每列都额外加了三个字段，分别用于存放事务id，回滚指针，行自增id。</p>
<p><a target="_blank" rel="noopener" href="https://jishuin.proginn.com/p/763bfbd3aaae">https://jishuin.proginn.com/p/763bfbd3aaae</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuwc/p/13873611.html">https://www.cnblogs.com/xuwc/p/13873611.html</a></p>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  计算机网络
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2021/09/09/hello-world/">
                hello-world
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>



	<div id="vcomments"></div>


<script>
	
		// 评论
		new Valine({
			av: AV,
			el: '#vcomments',
			notify: false,
			verify: false,
			path: window.location.pathname,
			appId: '',
			appKey: '',
			placeholder: '请输入评论',
			avatar: 'retro',
			recordIP: false
		})
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2021-<span id="footerYear"></span> 
	<a href="/">lsj</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>